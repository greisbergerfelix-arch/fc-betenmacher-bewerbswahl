<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>FC-Betenmacher – Auswertung (Beamer)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      background:#000;
      color:#fff;
      margin:0;
      padding:0;
    }
    .container {
      max-width:1400px;
      margin:0 auto;
      padding:20px 40px;
    }
    h1 {
      text-align:center;
      font-size:42px;
      margin:10px 0 5px;
    }
    h2 {
      text-align:center;
      font-size:28px;
      margin:10px 0 5px;
    }
    #count {
      font-size:26px;
      text-align:center;
      margin-top:10px;
    }
    .card {
      background:transparent;
      border:none;
      margin-bottom:40px;
    }
    .chart-wrapper {
      height:450px;
    }
    #status {
      text-align:center;
      font-size:16px;
      opacity:0.9;
      margin-top:8px;
    }

    /* CSV Export (neu, sonst nichts verändert) */
    #exportWrap{
      text-align:center;
      margin: 20px 0 10px;
    }
    #exportCsv{
      font-size:18px;
      padding:10px 16px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.08);
      color:#fff;
      cursor:pointer;
    }
    #exportCsv:active{ transform: translateY(1px); }
  </style>
</head>
<body>

<div id="app" class="container">
  <h1>FC-Betenmacher – Auswertung</h1>

  <div class="card">
    <p id="count">Lade …</p>
    <div id="status"></div>
  </div>

  <div class="card">
    <h2>Sportarten</h2>
    <div class="chart-wrapper">
      <canvas id="sportChart"></canvas>
    </div>
  </div>

  <div class="card">
    <h2>Sonstiges</h2>
    <div class="chart-wrapper">
      <canvas id="otherChart"></canvas>
    </div>
  </div>

  <!-- CSV Export (neu) -->
  <div id="exportWrap">
    <button id="exportCsv" type="button">CSV exportieren</button>
  </div>
</div>

<script>
/* ===================== Firebase ===================== */
const firebaseConfig = {
  apiKey: "AIzaSyCRkIU7F42QPrs2oMOymQxF4MVKM7oQZTw",
  authDomain: "fc-betenmacher-bewerbswa-b44e4.firebaseapp.com",
  databaseURL: "https://fc-betenmacher-bewerbswa-b44e4-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "fc-betenmacher-bewerbswa-b44e4",
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ===================== State ===================== */
let sportChart = null;
let otherChart = null;

/* CSV Export State (neu) */
let __exportState = {
  total: 0,
  sportEntries: [],
  otherEntries: [],
  ersatzList: [],        // [{cat,label,count}, ...] (1 oder mehrere)
  tie: false,
  stand: ""
};

function setStatus(text) {
  const el = document.getElementById('status');
  if (el) el.textContent = text || "";
}

/* ===================== Plugin: Text IM Balken (erst wenn Balken fertig) ===================== */
const valueLabelPlugin = {
  id: 'valueLabel',
  afterDatasetsDraw(chart) {
    const { ctx } = chart;
    const meta = chart.getDatasetMeta(0);
    const data = chart.data;
    if (!meta || !meta.data || meta.data.length === 0) return;

    const xScale = chart.scales.x;

    ctx.save();
    ctx.font = '16px Arial';
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    meta.data.forEach((bar, i) => {
      const value = data.datasets[0].data[i];
      const label = data.labels[i];
      const suffix = (data.suffixes && data.suffixes[i]) ? data.suffixes[i] : "";
      const text = `${label} (${value})${suffix}`;

      // Nur anzeigen, wenn der Balken wirklich am Ziel ist
      const targetX = xScale.getPixelForValue(value);
      const tolerance = 1.5; // Pixel-Toleranz
      if (Math.abs(bar.x - targetX) > tolerance) return;

      const centerX = (bar.x + bar.base) / 2;
      const centerY = bar.y;
      ctx.fillText(text, centerX, centerY);
    });

    ctx.restore();
  }
};

/* ===================== Helpers ===================== */
function sortEntries(obj) {
  return Object.entries(obj)
    .sort((a, b) => b[1] - a[1] || String(a[0]).localeCompare(String(b[0]), 'de'));
}
function safeArray(x) { return Array.isArray(x) ? x : []; }

function computeCounts(votesObj) {
  const sport = {};
  const other = {};
  let total = 0;

  Object.values(votesObj || {}).forEach(v => {
    if (!v || typeof v !== 'object') return;
    total++;

    safeArray(v.sport).forEach(s => { sport[s] = (sport[s] || 0) + 1; });
    safeArray(v.other).forEach(o => { other[o] = (other[o] || 0) + 1; });
  });

  return { sport, other, total };
}

/* Wenn Ersatzbewerb-Top aus Rest doppelt vorkommt (Tie), alle markieren */
function pickOverallErsatz(sportEntries, otherEntries) {
  const sportRest = sportEntries.slice(3).map(([label, count]) => ({ cat: "sport", label, count }));
  const otherRest = otherEntries.slice(3).map(([label, count]) => ({ cat: "other", label, count }));

  const candidates = sportRest.concat(otherRest);
  if (candidates.length === 0) return { list: [], tie: false };

  const maxCount = Math.max(...candidates.map(c => c.count));
  const top = candidates.filter(c => c.count === maxCount);

  // bei Gleichstand mehrere (Stechen) -> rot
  const tie = top.length > 1;

  // stabile Sortierung für Export
  top.sort((a, b) => String(a.label).localeCompare(String(b.label), 'de'));

  return { list: top, tie };
}

/* ===================== Farben + Suffix ===================== */
function prepareData(entries, ersatzNames, tie) {
  const labels = entries.map(e => e[0]);
  const values = entries.map(e => e[1]);

  const suffixes = [];
  const colors = [];

  labels.forEach((label, i) => {
    let suffix = "";
    if (ersatzNames && ersatzNames.includes(label)) suffix = " (Ersatzbewerb)";
    suffixes.push(suffix);

    if (i < 3) colors.push("rgba(34,197,94,0.85)");
    else if (ersatzNames && ersatzNames.includes(label) && tie) colors.push("rgba(239,68,68,0.9)");     // rot bei Tie
    else if (ersatzNames && ersatzNames.includes(label)) colors.push("rgba(234,179,8,0.9)");            // gelb bei Single
    else colors.push("rgba(148,163,184,0.9)");
  });

  return { labels, values, colors, suffixes };
}

/* ===================== Chart Rendering ===================== */
function drawChart(id, entries, type, ersatzNames, tie) {
  if (type === "sport" && sportChart) sportChart.destroy();
  if (type === "other" && otherChart) otherChart.destroy();

  const { labels, values, colors, suffixes } = prepareData(entries, ersatzNames, tie);
  const ersatzIndices = (ersatzNames && ersatzNames.length)
    ? ersatzNames.map(n => labels.indexOf(n)).filter(i => i >= 0)
    : [];
  const maxVal = Math.max(0, ...values);

  const canvas = document.getElementById(id);
  if (!canvas) return;
  const ctx = canvas.getContext("2d");

  const chart = new Chart(ctx, {
    type: "bar",
    data: {
      labels,
      suffixes,
      datasets: [{
        data: values,
        backgroundColor: colors
      }]
    },
    options: {
      indexAxis: "y",
      responsive: true,
      maintainAspectRatio: false,

      // Balken mit wenig Stimmen schneller, Maximum ca. 15s
      animations: {
        x: {
          from: 0,
          duration: (ctx) => {
            const v = Number(ctx.raw || 0);
            if (!maxVal) return 0;
            const ms = Math.round(15000 * (v / maxVal)); // <= HIER: 15000 = max. 15s
            return Math.max(250, ms); // Minimum, damit man es sieht
          }
        },
        y: { duration: 0 } // Position nicht animieren
      },

      plugins: {
        legend: { display:false },
        tooltip: { enabled:true }
      },
      scales: {
        x: {
          beginAtZero:true,
          ticks:{ display:false },
          grid:{ display:false }
        },
        y: {
          ticks: {
            display: true,
            color: "#fff",
            callback: (v, i) => {
              if (i < 3) return String(i + 1);                 // 1,2,3 links
              if (ersatzIndices.includes(i)) return "E";       // Ersatzbewerb (auch bei Tie)
              return "";                                       // sonst nichts
            }
          },
          grid:{ display:false }
        }
      }
    },
    plugins:[valueLabelPlugin]
  });

  if (type === "sport") sportChart = chart;
  else otherChart = chart;
}

/* ===================== CSV Export (neu) ===================== */
function csvEscape(s) {
  const str = String(s ?? "");
  if (/[",\n\r;]/.test(str)) return '"' + str.replace(/"/g, '""') + '"';
  return str;
}
function downloadCSV(filename, csvText) {
  // BOM für Excel
  const blob = new Blob(["\uFEFF" + csvText], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
document.getElementById("exportCsv").addEventListener("click", () => {
  const st = __exportState;
  const tie = st.tie;

  const lines = [];
  lines.push([
    "stand",
    "abgegebene_stimmen",
    "kategorie",
    "rang_in_kategorie",
    "label",
    "stimmen",
    "top3",
    "ersatzbewerb",
    "stechen"
  ].join(";"));

  function addCategory(catName, entries) {
    entries.forEach(([label, count], idx) => {
      const rank = idx + 1;
      const top3 = rank <= 3 ? 1 : 0;
      const ersatz = st.ersatzList.some(e => e.cat === catName && e.label === label) ? 1 : 0;
      const stechen = (tie && ersatz) ? 1 : 0;
      lines.push([
        csvEscape(st.stand),
        st.total,
        csvEscape(catName === "sport" ? "Sportarten" : "Sonstiges"),
        rank,
        csvEscape(label),
        count,
        top3,
        ersatz,
        stechen
      ].join(";"));
    });
  }

  addCategory("sport", st.sportEntries);
  addCategory("other", st.otherEntries);

  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
  downloadCSV(`FC-Betenmacher_Auswertung_${stamp}.csv`, lines.join("\n"));
});

/* ===================== Load ===================== */
db.ref('votes').once('value').then(snap => {
  const votes = snap.val() || {};
  const { sport, other, total } = computeCounts(votes);

  document.getElementById('count').innerText = 'Abgegebene Stimmen: ' + total;

  const sportEntries = sortEntries(sport);
  const otherEntries = sortEntries(other);

  const ersatzPick = pickOverallErsatz(sportEntries, otherEntries);
  const ersatzList = ersatzPick.list;
  const tie = ersatzPick.tie;

  const sportErsatzNames = ersatzList.filter(e => e.cat === "sport").map(e => e.label);
  const otherErsatzNames = ersatzList.filter(e => e.cat === "other").map(e => e.label);

  drawChart("sportChart", sportEntries, "sport", sportErsatzNames.length ? sportErsatzNames : null, tie);
  drawChart("otherChart", otherEntries, "other", otherErsatzNames.length ? otherErsatzNames : null, tie);

  const stand = new Date().toLocaleString('de-AT');
  setStatus("Stand: " + stand);

  // Export-State befüllen (neu)
  __exportState.total = total;
  __exportState.sportEntries = sportEntries;
  __exportState.otherEntries = otherEntries;
  __exportState.ersatzList = ersatzList;
  __exportState.tie = tie;
  __exportState.stand = stand;

}).catch(err => {
  console.error("Fehler beim Lesen von /votes:", err);
  document.getElementById('count').innerText = 'Fehler beim Laden.';
  setStatus("Fehler: " + (err && err.message ? err.message : "Keine Berechtigung (Rules) oder Netzwerkproblem."));
});
</script>
</body>
</html>
